#!/bin/bash

# ==============================================================================
# Title:        PDF Merger
# Description:  Libadwaita GUI to reorder and merge PDFs using Ghostscript.
# License: GPLv2 or later
# ==============================================================================

# --- 1. LOGGING ---
exec 2> /tmp/pdf_merger.log

# --- 2. DEPENDENCY CHECK ---
check_dep() {
    if ! command -v "$1" &> /dev/null; then
        zenity --error --text="Missing Tool: <b>$1</b>" --width=300
        exit 1
    fi
}
check_dep python3
check_dep gs
check_dep file

# --- 3. INPUT VALIDATION ---
if [ $# -eq 0 ]; then
    zenity --info --text="<b>PDF Merger</b>\n\nSelect multiple PDF files in Nautilus -> Scripts -> PDF Merger." --width=350
    exit 0
fi

# --- 4. GUI ENGINE ---
GUI_SCRIPT=$(mktemp)
cat <<'EOF' > "$GUI_SCRIPT"
import sys
import os
import subprocess
import threading
import gi

gi.require_version('Gtk', '4.0')
gi.require_version('Adw', '1')
from gi.repository import Gtk, Adw, GLib, Gio, Gdk

APP_ID = 'com.tools.pdfmerger'

class PdfMergerApp(Adw.Application):
    def __init__(self, raw_files):
        super().__init__(application_id=APP_ID)
        self.raw_files = raw_files
        self.valid_pdfs = []
        self.skipped_count = 0

    def do_activate(self):
        # Filter files first
        self.filter_pdfs()

        win = Adw.ApplicationWindow(application=self)
        win.set_title("PDF Merger")
        win.set_default_size(500, 600)
        
        # Toast Overlay for notifications
        self.toast_overlay = Adw.ToastOverlay()
        win.set_content(self.toast_overlay)

        # Main Structure
        self.stack = Adw.ViewStack()
        
        # Header
        self.header = Adw.HeaderBar()
        
        toolbar_view = Adw.ToolbarView()
        toolbar_view.add_top_bar(self.header)
        toolbar_view.set_content(self.stack)
        self.toast_overlay.set_child(toolbar_view)

        # ===========================
        # PAGE 1: EDITOR LIST
        # ===========================
        page_edit = Gtk.Box(orientation=Gtk.Orientation.VERTICAL)
        
        # Scroll Window
        scroller = Gtk.ScrolledWindow()
        scroller.set_vexpand(True)
        
        # The Clamp makes it look like a settings page list
        clamp = Adw.Clamp(maximum_size=450)
        clamp.set_margin_top(20)
        clamp.set_margin_bottom(20)
        
        # The List Box
        self.list_box = Gtk.ListBox()
        self.list_box.add_css_class("boxed-list")
        self.list_box.set_selection_mode(Gtk.SelectionMode.NONE)
        
        for f in self.valid_pdfs:
            self.add_row(f)

        clamp.set_child(self.list_box)
        scroller.set_child(clamp)
        page_edit.append(scroller)
        
        # Merge Button (Bottom Bar)
        action_bar = Gtk.ActionBar()
        self.btn_merge = Gtk.Button(label="Merge PDFs")
        self.btn_merge.add_css_class("suggested-action")
        self.btn_merge.add_css_class("pill")
        self.btn_merge.connect("clicked", self.on_merge_clicked)
        
        # Center the button
        box_btn = Gtk.Box(halign=Gtk.Align.CENTER)
        box_btn.append(self.btn_merge)
        action_bar.set_center_widget(box_btn)
        
        page_edit.append(action_bar)
        
        self.stack.add_named(page_edit, "edit")

        # ===========================
        # PAGE 2: PROGRESS
        # ===========================
        self.page_progress = Adw.StatusPage()
        self.page_progress.set_icon_name("printer-printing-symbolic")
        self.page_progress.set_title("Merging...")
        
        self.spinner = Gtk.Spinner()
        self.spinner.set_size_request(48, 48)
        self.page_progress.set_child(self.spinner)
        
        self.stack.add_named(self.page_progress, "progress")

        # ===========================
        # PAGE 3: SUCCESS
        # ===========================
        page_success = Adw.StatusPage()
        page_success.set_icon_name("document-save-symbolic")
        page_success.set_title("PDF Created")
        
        self.lbl_success = Gtk.Label(label="")
        self.lbl_success.add_css_class("body")
        
        btn_box = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=10)
        btn_box.set_halign(Gtk.Align.CENTER)
        
        btn_open = Gtk.Button(label="Open File")
        btn_open.connect("clicked", self.on_open_clicked)
        
        btn_close = Gtk.Button(label="Close")
        btn_close.add_css_class("pill")
        btn_close.connect("clicked", lambda x: self.quit())
        
        btn_box.append(btn_open)
        btn_box.append(btn_close)
        
        # StatusPage only takes one child, so we wrap content
        wrapper = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=20)
        wrapper.append(self.lbl_success)
        wrapper.append(btn_box)
        
        page_success.set_child(wrapper)
        self.stack.add_named(page_success, "success")

        win.present()

        # Show notification if files were skipped
        if self.skipped_count > 0:
            self.show_toast(f"Skipped {self.skipped_count} invalid files.")
            
        if len(self.valid_pdfs) < 2:
            self.btn_merge.set_sensitive(False)
            self.show_toast("Select at least 2 PDFs to merge.")

    def filter_pdfs(self):
        # Pre-sort alphabetically to start
        sorted_files = sorted(self.raw_files)
        
        for f in sorted_files:
            try:
                mime = subprocess.check_output(["file", "--brief", "--mime-type", f], text=True).strip()
                if mime == "application/pdf":
                    self.valid_pdfs.append(f)
                else:
                    self.skipped_count += 1
            except:
                self.skipped_count += 1

    def add_row(self, filepath):
        row = Adw.ActionRow(title=os.path.basename(filepath))
        # Store full path in the widget for retrieval later
        row._file_path = filepath
        
        # Up Button
        btn_up = Gtk.Button(icon_name="go-up-symbolic")
        btn_up.add_css_class("flat")
        btn_up.connect("clicked", self.move_row, row, -1)
        
        # Down Button
        btn_down = Gtk.Button(icon_name="go-down-symbolic")
        btn_down.add_css_class("flat")
        btn_down.connect("clicked", self.move_row, row, 1)
        
        # Remove Button
        btn_del = Gtk.Button(icon_name="user-trash-symbolic")
        btn_del.add_css_class("flat")
        btn_del.add_css_class("error")
        btn_del.connect("clicked", self.remove_row, row)

        row.add_suffix(btn_up)
        row.add_suffix(btn_down)
        row.add_suffix(btn_del)
        
        self.list_box.append(row)

    def move_row(self, btn, row, direction):
        index = row.get_index()
        new_index = index + direction
        
        # Bounds check
        # Note: GtkListBox doesn't have a simple 'get_n_rows' in all versions easily accessible
        # We handle bounds by logic.
        if new_index < 0: return
        
        # Swap widgets
        current_row = self.list_box.get_row_at_index(index)
        target_row = self.list_box.get_row_at_index(new_index)
        
        if target_row is None: return
        
        # To move, we actually just remove and insert
        # NOTE: In GTK4 ListBox, changing sort order programmatically without a sort func is tricky.
        # The cleanest way without a custom model is to unparent and insert.
        
        # We take the widget out
        self.list_box.remove(current_row)
        self.list_box.insert(current_row, new_index)
        
        # Keep focus
        current_row.grab_focus()

    def remove_row(self, btn, row):
        self.list_box.remove(row)
        # Check if enough files remain
        count = 0
        child = self.list_box.get_first_child()
        while child:
            count += 1
            child = child.get_next_sibling()
        
        if count < 2:
            self.btn_merge.set_sensitive(False)

    def show_toast(self, msg):
        toast = Adw.Toast.new(msg)
        self.toast_overlay.add_toast(toast)

    def on_merge_clicked(self, btn):
        # 1. Gather ordered file list
        files_to_merge = []
        child = self.list_box.get_first_child()
        while child:
            files_to_merge.append(child._file_path)
            child = child.get_next_sibling()
            
        if len(files_to_merge) < 2: return

        # 2. Show Save Dialog
        # Gtk4 FileDialog is new, let's use FileChooserNative for max compat
        dialog = Gtk.FileChooserNative(
            title="Save Merged PDF",
            transient_for=self.get_active_window(),
            action=Gtk.FileChooserAction.SAVE,
            accept_label="_Save",
            cancel_label="_Cancel"
        )
        
        # Suggest filename based on first file's folder
        base_dir = os.path.dirname(files_to_merge[0])
        dialog.set_current_folder(Gio.File.new_for_path(base_dir))
        dialog.set_current_name("Merged_Document.pdf")
        
        filter_pdf = Gtk.FileFilter()
        filter_pdf.set_name("PDF Documents")
        filter_pdf.add_mime_type("application/pdf")
        dialog.add_filter(filter_pdf)
        
        dialog.connect("response", self.on_save_response, files_to_merge)
        dialog.show()

    def on_save_response(self, dialog, response, files_to_merge):
        if response == Gtk.ResponseType.ACCEPT:
            self.output_file = dialog.get_file().get_path()
            if not self.output_file.endswith(".pdf"):
                self.output_file += ".pdf"
            
            dialog.destroy()
            
            # Start Merging
            self.stack.set_visible_child_name("progress")
            self.header.set_show_end_title_buttons(False)
            self.spinner.start()
            
            thread = threading.Thread(target=self.run_ghostscript, args=(files_to_merge,))
            thread.start()
        else:
            dialog.destroy()

    def run_ghostscript(self, files):
        try:
            # Ghostscript command
            cmd = [
                "gs", "-dBATCH", "-dNOPAUSE", "-q", 
                "-sDEVICE=pdfwrite", 
                "-dPDFSETTINGS=/prepress", 
                f"-sOutputFile={self.output_file}"
            ] + files
            
            subprocess.run(cmd, check=True)
            GLib.idle_add(self.on_success)
            
        except Exception as e:
            GLib.idle_add(self.on_error, str(e))

    def on_success(self):
        self.spinner.stop()
        self.stack.set_visible_child_name("success")
        self.header.set_show_end_title_buttons(True)
        self.lbl_success.set_label(f"Saved to:\n{os.path.basename(self.output_file)}")

    def on_error(self, msg):
        self.spinner.stop()
        self.header.set_show_end_title_buttons(True)
        self.show_toast(f"Error: {msg}")
        self.stack.set_visible_child_name("edit") # Go back to edit to try again

    def on_open_clicked(self, btn):
        subprocess.Popen(["xdg-open", self.output_file])
        self.quit()

if __name__ == "__main__":
    raw = sys.argv[1:]
    app = PdfMergerApp(raw)
    app.run([])
EOF

# --- 5. EXECUTION ---
python3 "$GUI_SCRIPT" "$@"

# --- 6. CLEANUP ---
rm -f "$GUI_SCRIPT"
exit 0
